# Why Queries May Run Slower on MotherDuck Than Locally

While MotherDuck extends DuckDB's powerful local analytics capabilities to the cloud, there are specific scenarios where queries may run slower on MotherDuck compared to local execution. Understanding these performance trade-offs helps you optimize your query execution strategy.

## Network Data Transfer Overhead

The primary reason queries may run slower on MotherDuck is **network data transfer**. When a query executes remotely in the cloud, the final result set must be transferred over the network back to your local client. This introduces latency that doesn't exist with purely local execution.

### When This Matters Most

Network overhead becomes significant when:
- **Large result sets**: Queries returning millions of rows must transfer all that data over the network
- **Geographic distance**: Greater distance between your location and MotherDuck's servers (currently in AWS us-east-1 and eu-central-1) increases latency
- **Limited bandwidth**: Slower internet connections create bottlenecks for data transfer

## Local vs. Remote Execution: The Trade-offs

MotherDuck's **dual execution model** intelligently decides whether to run queries locally or remotely based on where the data lives. However, this optimization isn't always perfect for every scenario.

### When Local is Faster

Local execution excels when:
- **Small local files**: Querying a CSV or Parquet file on your laptop runs entirely locally with zero network overhead
- **Results are immediately available**: The in-process architecture eliminates all network latency
- **Your machine has sufficient resources**: Modern hardware with multiple cores and substantial RAM can handle many analytical workloads efficiently

### When Remote (MotherDuck) is Faster

Remote execution on MotherDuck is typically faster when:
- **Data is already in the cloud**: Querying large tables stored in MotherDuck avoids downloading the entire dataset
- **Cloud storage access**: Accessing data from S3 or other cloud storage is faster from MotherDuck's cloud infrastructure due to high-bandwidth connections and network proximity. In benchmarks, queries that took 11 seconds locally completed in just 2 seconds on MotherDuck
- **Compute-intensive operations**: MotherDuck's dedicated "ducklings" (containerized DuckDB instances) provide scaled compute resources that may exceed your local machine's capabilities

## The Data Download Factor

A critical performance consideration is **where your source data lives**. As demonstrated in MotherDuck's dual execution documentation:

> A direct comparison showed that querying a 2GB Parquet file on S3 was significantly faster when executed remotely in MotherDuck (25 seconds) compared to a local DuckDB client that had to first download the data (36 seconds).

When you force a query to run locally against remote data (using `md_run = 'local'`), your client must:
1. Download the entire dataset from cloud storage
2. Then process it locally

This download step adds substantial overhead that makes local execution slower than remote execution in the cloud, where the compute is already near the data.

## Hybrid Query Performance Considerations

MotherDuck's most powerful feature—hybrid queries that join local and cloud data—involves careful performance trade-offs:

- **Intelligent optimization**: The system efficiently transfers only necessary intermediate data to complete joins
- **Avoids unnecessary transfers**: It doesn't upload your entire local file or download the entire remote table
- **Network still required**: Some data must move between local and cloud, introducing latency that wouldn't exist in a purely local or purely cloud query

## Distributed System Overhead

While MotherDuck minimizes the complexity of distributed systems, some overhead is inherent when coordinating between local and cloud execution:

- **Query planning**: The dual execution optimizer must analyze where data lives and decide execution strategy
- **Coordination**: Managing the split between local and remote operations requires communication
- **Result aggregation**: When operations happen in both locations, results must be combined

## Small Data Paradox

For very small datasets (under a few hundred megabytes), local DuckDB is often faster because:
- **Setup time**: There's minimal overhead to just read a local file
- **Transfer costs exceed compute benefits**: The time to transfer even a small result set over the network may exceed the entire local query execution time
- **In-memory advantages**: DuckDB's in-process architecture has zero network hops

As MotherDuck's documentation notes, approximately 94% of analytical workloads involve data below 10TB, and modern single machines can handle datasets up to 24TB in memory. For many of these smaller workloads, local execution can be optimal.

## Optimization Strategies

To minimize slowdowns when using MotherDuck:

1. **Understand dual execution**: Use `EXPLAIN` to see which parts of your query run locally vs. remotely
2. **Control execution location**: Use the `md_run` parameter (`'local'` or `'remote'`) in scan functions to override automatic decisions when you know better
3. **Minimize result set size**: Apply filters and aggregations to reduce data transferred over the network
4. **Consider data locality**: Store frequently-queried data in MotherDuck rather than forcing remote access from local queries
5. **Use Read Scaling for BI tools**: For high-concurrency scenarios, MotherDuck's Read Scaling feature distributes queries across multiple replicas, avoiding the "noisy neighbor" problem

## The Bottom Line

Queries may run slower on MotherDuck than locally primarily due to **network transfer overhead** when moving data between your machine and the cloud. However, this is only part of the story. MotherDuck is actually faster than local execution when:
- Data already lives in the cloud
- You're accessing cloud storage (S3, GCS, etc.)
- You need more compute resources than your local machine provides
- You're running high-concurrency workloads

MotherDuck's architecture is designed to **minimize data movement** and **push computation to where data lives**—the key principle behind its dual execution model. Understanding when to leverage local vs. remote execution helps you get the best performance for your specific workload.

## Sources

1. **Bringing DuckDB to the Cloud: Dual Execution Explained** - https://motherduck.com/videos/bringing-duckdb-to-the-cloud-dual-execution-explained
   - Explains dual execution architecture and hybrid query optimization
   - Documents the 2GB S3 file benchmark: 25 seconds remote vs. 36 seconds local
   - Describes how the system minimizes data movement

2. **Stay in Flow with MotherDuck's Instant SQL** - https://motherduck.com/videos/stay-in-flow-with-motherducks-instant-sql
   - Covers MotherDuck's architecture built on three core pillars
   - Explains dual execution query engine capabilities
   - Notes that 99% of queries fit on a single large node

3. **Fix Slow BI Dashboards: A Guide to Sub-Second Analytics** - https://motherduck.com/learn-more/fix-slow-bi-dashboards
   - Documents how dual execution intelligently pushes computation to where data lives
   - Explains Read Scaling for high-concurrency scenarios
   - Describes network latency minimization strategies

4. **DuckDB & MotherDuck for Beginners: Your Ultimate Guide** - https://motherduck.com/videos/duckdb-motherduck-for-beginners-your-ultimate-guide
   - Benchmarks showing queries completing in 2 seconds on MotherDuck vs. 11 seconds locally
   - Explains in-process architecture and elimination of network overhead for local operations
   - Notes that 94% of workloads involve data below 10TB
